## select/poll瓶颈
### 1、线性扫描
每次调用 select/poll 时，内核都需要线性扫描所有被监视的文件描述符集合，以检查哪些描述符就绪。当监控的 fd 数量很大（如数万个），但其中只有少数是活跃的时，这种扫描的效率非常低（时间复杂度 O(n)）。
### 2、数据拷贝
每次调用时，应用程序都需要将整个需要监视的 fd 集合（一个大的数据结构）从用户空间拷贝到内核空间。当调用返回时，内核又将修改后的（包含就绪状态的）集合从内核空间拷贝回用户空间。大量的 fd 集合在用户态和内核态之间来回拷贝，开销巨大。
### 内存开销
select 使用固定大小的位图，其大小受 FD_SETSIZE 限制（通常为 1024）。poll 虽然无此限制，但传递的 pollfd 结构数组在 fd 数量很大时，本身也会占用可观的内存。
## epoll优势
第一招：epoll_create - 创建内核事件表
当你调用 epoll_create1 时，内核会创建一个名为 eventpoll 的结构体。这个结构体是 epoll 的核心，它包含两个关键成员：

红黑树 (Red-Black Tree)： 用于存储所有需要监控的文件描述符，以及应用程序感兴趣的事件（如 EPOLLIN, EPOLLOUT）。这颗树使得对 fd 的 添加(EPOLL_CTL_ADD)、删除(EPOLL_CTL_DEL)、修改(EPOLL_CTL_MOD) 操作都非常高效，时间复杂度为 O(log n)。
就绪链表 (Ready List)： 一个双向链表，用于存放已经就绪（有事件发生）的文件描述符。
关键点： 这个 eventpoll 对象存在于内核空间，只需创建一次，并在后续的 epoll_ctl 和 epoll_wait 调用中重复使用。这就避免了每次调用都向内核传递整个 fd 集合的问题。

第二招：epoll_ctl - 管理监控列表
使用 epoll_ctl 可以向 eventpoll 的内核事件表（红黑树）中 添加、修改或删除 要监控的 fd。

最重要的机制：回调函数 (Callback Function) 当你通过 epoll_ctl 添加一个 fd 时，内核会为这个 fd 注册一个回调函数（在设备驱动程序中）。当网络数据到达网卡，或 socket 缓冲区状态发生变化时，内核会触发中断，最终这个回调函数会被调用。

回调函数的作用： 它会将发生事件的 fd 对应的 epitem 结构（红黑树上的节点）添加到 eventpoll 的就绪链表中。

关键优势：

事件驱动： 内核不再需要主动去轮询所有 fd 的状态。而是被动地等待事件发生，然后通过回调函数来通知。
O(1) 复杂度： 将就绪的 fd 添加到链表的操作是 O(1) 的。这意味着，即使你监控了 100 万个 fd，当只有一个 fd 就绪时，内核也只处理这一个 fd，效率与监控总量无关。
第三招：epoll_wait - 获取就绪事件
应用程序调用 epoll_wait 来等待事件发生。它的工作非常简单：

检查 eventpoll 的就绪链表是否为空。
如果链表不为空，说明有 fd 已经就绪。内核将这些就绪的事件拷贝到用户空间提供的数组中。
如果链表为空，当前进程/线程会进入睡眠状态，直到超时或有回调函数向就绪链表添加了新的项目后被唤醒。